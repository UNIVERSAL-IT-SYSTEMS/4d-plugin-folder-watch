/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Folder Watch
 #	author : miyako
 #	2015/01/26
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"

namespace FW
{
    process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0F\0O\0L\0D\0E\0R\0_\0W\0A\0T\0C\0H\0\0\0";
				process_number_t MONITOR_PROCESS_ID = 0;
    process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
    method_id_t CALLBACK_METHOD_ID = 0;
				bool MONITOR_PROCESS_SHOULD_TERMINATE;
				C_TEXT LISTENER_METHOD;
				C_TEXT WATCH_PATH;
				C_TEXT WATCH_METHOD;
				std::string WATCH_PATH_POSIX;
				const char *DISPATCH_QUEUE_NAME = "FOLDER_WATCH_QUEUE";
				dispatch_queue_t DISPATCH_QUEUE;
				dispatch_source_t DISPATCH_SOURCE;
				int DESCRIPTOR = 0;
				dispatch_source_vnode_flags_t DISPATCH_FLAGS = DISPATCH_VNODE_WRITE|DISPATCH_VNODE_DELETE|DISPATCH_VNODE_EXTEND;
				std::vector<NSTimeInterval>CALLBACK_EVENT_IDS;
}

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

bool IsProcessOnExit()
{
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    CUTF16String procName(name.getUTF16StringPtr());
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

void OnStartup()
{
    
}

void OnCloseProcess()
{
    if(IsProcessOnExit())
				{
        listenerLoopFinish();
    }
}

#pragma mark -

void listenerLoop()
{
    FW::MONITOR_PROCESS_SHOULD_TERMINATE = false;
        
    while(!FW::MONITOR_PROCESS_SHOULD_TERMINATE)
    { 
        PA_YieldAbsolute();
								while(FW::CALLBACK_EVENT_IDS.size())
								{
												PA_YieldAbsolute();
            C_TEXT processName;
            generateUuid(processName);
            PA_NewProcess((void *)listenerLoopExecuteMethod, 
                          FW::MONITOR_PROCESS_STACK_SIZE, 
                          (PA_Unichar *)processName.getUTF16StringPtr());
												
												if(FW::MONITOR_PROCESS_SHOULD_TERMINATE)
																break;
								}
								
        if(!FW::MONITOR_PROCESS_SHOULD_TERMINATE)
								{
            PA_FreezeProcess(PA_GetCurrentProcessNumber());
        }else{
            FW::MONITOR_PROCESS_ID = 0;
        }
    }
    PA_KillProcess();
}

void listenerLoopStart()
{
    if(!FW::MONITOR_PROCESS_ID)
				{
        FW::MONITOR_PROCESS_ID = PA_NewProcess((void *)listenerLoop, 
                                                         FW::MONITOR_PROCESS_STACK_SIZE, 
                                                         FW::MONITOR_PROCESS_NAME);
#if VERSIONMAC  
        
        FW::DESCRIPTOR = open(FW::WATCH_PATH_POSIX.c_str(), O_EVTONLY);
        FW::DISPATCH_QUEUE = dispatch_queue_create(FW::DISPATCH_QUEUE_NAME, 0);
        FW::DISPATCH_SOURCE = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,
                                                                FW::DESCRIPTOR,
                                                                FW::DISPATCH_FLAGS,
                                                                FW::DISPATCH_QUEUE);
        
        dispatch_source_set_event_handler(FW::DISPATCH_SOURCE, ^(){
            listenerLoopExecute();
        });
        
        dispatch_source_set_cancel_handler(FW::DISPATCH_SOURCE, ^(){
            close(FW::DESCRIPTOR);
            FW::DESCRIPTOR = 0;
        });
        
        dispatch_resume(FW::DISPATCH_SOURCE);        
#else
        
#endif         
    }
}

void listenerLoopFinish()
{
    if(FW::MONITOR_PROCESS_ID)
				{
        //uninstall handler 
#if VERSIONMAC         
        dispatch_source_set_event_handler_f(FW::DISPATCH_SOURCE, NULL);      
        dispatch_source_cancel(FW::DISPATCH_SOURCE);
#else
        
#endif 
        //set flags
        FW::MONITOR_PROCESS_SHOULD_TERMINATE = true;
        PA_YieldAbsolute();
								FW::WATCH_PATH.setUTF16String((PA_Unichar *)"\0\0", 0);
								FW::WATCH_PATH_POSIX = "";
								FW::CALLBACK_METHOD_ID = 0;
								FW::CALLBACK_EVENT_IDS.clear();
        //tell listener to die
        while(FW::MONITOR_PROCESS_ID)
								{
            PA_YieldAbsolute();
            PA_UnfreezeProcess(FW::MONITOR_PROCESS_ID);
        }
    }
} 

void listenerLoopExecute()
{
    FW::MONITOR_PROCESS_SHOULD_TERMINATE = false;
				FW::CALLBACK_EVENT_IDS.push_back([[NSDate date]timeIntervalSince1970]);
    PA_UnfreezeProcess(FW::MONITOR_PROCESS_ID);
}

void listenerLoopExecuteMethod()
{
				std::vector<NSTimeInterval>::iterator e = FW::CALLBACK_EVENT_IDS.begin();
				double ts = *e;
				
    if(FW::CALLBACK_METHOD_ID)
				{
        PA_Variable	params[2];
        params[0] = PA_CreateVariable(eVK_Unistring);
								params[1] = PA_CreateVariable(eVK_Real);
								PA_Unistring path = PA_CreateUnistring((PA_Unichar *)FW::WATCH_PATH.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &path);
								PA_SetRealVariable(&params[1], ts);
								FW::CALLBACK_EVENT_IDS.erase(e);
        PA_ExecuteMethodByID(FW::CALLBACK_METHOD_ID, params, 2);
        //PA_DisposeUnistring(&path);//removed 15.11.20 (clear will dispose string too)
        PA_ClearVariable(&params[0]);//added 15.11.19
								PA_ClearVariable(&params[1]);
    }else{
								FW::CALLBACK_EVENT_IDS.erase(e);
				}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher(PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :            
            OnStartup();
            break;
            
        case kCloseProcess :            
            OnCloseProcess();
            break;
            
// --- Settings

		case 1 :
			FOLDER_Set_watch_path(pResult, pParams);
			break;

		case 2 :
			FOLDER_Get_watch_path(pResult, pParams);
			break;

		case 3 :
			FOLDER_Set_watch_method(pResult, pParams);
			break;

		case 4 :
			FOLDER_Get_watch_method(pResult, pParams);
			break;

	}
}

#pragma mark -

// ----------------------------------- Settings -----------------------------------

void FOLDER_Set_watch_path(sLONG_PTR *pResult, PackagePtr pParams)
{ 
				C_TEXT Param1;
				C_LONGINT returnValue;

				Param1.fromParamAtIndex(pParams, 1);
    
    if(!Param1.getUTF16Length())
				{
								//empty string passed
        returnValue.setIntValue(1);
        if(FW::WATCH_PATH.getUTF16Length())	//current path is not empty
												listenerLoopFinish();											//this will also clear the watch path

    }else{
    
        BOOL isDirectory = false;    
        NSString *path = Param1.copyPath();
        NSString *pathHFS = Param1.copyUTF16String();
        
        if([[NSFileManager defaultManager]fileExistsAtPath:path isDirectory:&isDirectory])
								{
            if(isDirectory)
												{
                returnValue.setIntValue(1);
																
                if(FW::WATCH_PATH.getUTF16Length())
                    listenerLoopFinish();

                FW::WATCH_PATH.setUTF16String(pathHFS); 
                FW::WATCH_PATH_POSIX = (const char *)[path UTF8String];
																
																listenerLoopStart();//restart always
                
            }else{
                returnValue.setIntValue(MONITOR_FOLDER_NOT_FOLDER_ERROR);
            }
            
        }else{
            returnValue.setIntValue(MONITOR_FOLDER_INVALID_PATH_ERROR);
        }
        
        [path release];
        [pathHFS release];
								
    }
    
	returnValue.setReturn(pResult);
}

void FOLDER_Set_watch_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    if(!Param1.getUTF16Length())
				{
								//empty string passed
        returnValue.setIntValue(1);
								FW::CALLBACK_METHOD_ID = 0;
								FW::WATCH_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
        
    }else{  
        
        method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param1.getUTF16StringPtr());
        
        if(methodId)
								{
            returnValue.setIntValue(1);
            
            if(methodId != FW::CALLBACK_METHOD_ID)
												{
                FW::WATCH_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
                FW::CALLBACK_METHOD_ID = methodId;
            }
        }else{
            returnValue.setIntValue(MONITOR_FOLDER_INVALID_METHOD_NAME_ERROR);
        }
    }
  
	returnValue.setReturn(pResult);
}

void FOLDER_Get_watch_path(sLONG_PTR *pResult, PackagePtr pParams)
{
				FW::WATCH_PATH.setReturn(pResult);
}

void FOLDER_Get_watch_method(sLONG_PTR *pResult, PackagePtr pParams)
{
				FW::WATCH_PATH.setReturn(pResult);
}
